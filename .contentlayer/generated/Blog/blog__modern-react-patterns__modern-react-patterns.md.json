{
  "title": "Modern React Patterns for Scalable Applications",
  "date": "2024-11-15T00:00:00.000Z",
  "summary": "Learn about compound components, render props, custom hooks, and other patterns that will make your React code more reusable and maintainable.",
  "tags": [
    "React",
    "JavaScript",
    "Design Patterns",
    "Frontend"
  ],
  "cover": "cover.jpg",
  "body": {
    "raw": "author: \"Ehsan Pourhadi\"\n---\n\n# Modern React Patterns for Scalable Applications\n\nReact has evolved significantly since its introduction, and with it, the patterns and practices that help us build better applications. In this article, we'll explore some of the most effective React patterns that can help you create more maintainable, reusable, and scalable code.\n\n## 1. Compound Components\n\nCompound components allow you to create flexible APIs by composing multiple components together. This pattern is excellent for building reusable UI components that need to work together.\n\n```jsx\n// Before: Monolithic component with many props\n<Dropdown\n  trigger=\"Select option\"\n  options={[\n    { value: 'option1', label: 'Option 1' },\n    { value: 'option2', label: 'Option 2' }\n  ]}\n  onSelect={handleSelect}\n  className=\"custom-dropdown\"\n/>\n\n// After: Compound components for flexibility\n<Dropdown onSelect={handleSelect}>\n  <Dropdown.Trigger>Select option</Dropdown.Trigger>\n  <Dropdown.Content>\n    <Dropdown.Item value=\"option1\">Option 1</Dropdown.Item>\n    <Dropdown.Item value=\"option2\">Option 2</Dropdown.Item>\n  </Dropdown.Content>\n</Dropdown>\n```\n\n### Implementation\n\n```jsx\nconst DropdownContext = createContext();\n\nexport const Dropdown = ({ children, onSelect }) => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const value = {\n    isOpen,\n    setIsOpen,\n    onSelect,\n  };\n\n  return (\n    <DropdownContext.Provider value={value}>\n      <div className=\"dropdown\">{children}</div>\n    </DropdownContext.Provider>\n  );\n};\n\nDropdown.Trigger = ({ children }) => {\n  const { isOpen, setIsOpen } = useContext(DropdownContext);\n\n  return <button onClick={() => setIsOpen(!isOpen)}>{children}</button>;\n};\n\nDropdown.Content = ({ children }) => {\n  const { isOpen } = useContext(DropdownContext);\n\n  return isOpen ? <div className=\"dropdown-content\">{children}</div> : null;\n};\n```\n\n## 2. Custom Hooks for Logic Reuse\n\nCustom hooks are perfect for extracting and reusing stateful logic across components. They promote the DRY principle and make your components cleaner.\n\n```jsx\n// Custom hook for API data fetching\nexport const useApi = (url, options = {}) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url, options);\n\n        if (!response.ok) {\n          throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n        }\n\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n};\n\n// Usage in components\nconst UserProfile = ({ userId }) => {\n  const { data: user, loading, error } = useApi(\\`/api/users/\\${userId}\\`);\n\n  if (loading) return <Spinner />;\n  if (error) return <Error message={error} />;\n  if (!user) return <NotFound />;\n\n  return <ProfileCard user={user} />;\n};\n```\n\n## 3. Render Props Pattern\n\nThe render props pattern provides a way to share code between components using a prop whose value is a function.\n\n```jsx\n// Render props component for mouse tracking\nexport const MouseTracker = ({ render }) => {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setPosition({ x: event.clientX, y: event.clientY });\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    return () => window.removeEventListener(\"mousemove\", handleMouseMove);\n  }, []);\n\n  return render(position);\n};\n\n// Usage\nconst App = () => {\n  return (\n    <MouseTracker\n      render={(position) => (\n        <div>\n          <h1>Mouse position:</h1>\n          <p>\n            X: {position.x}, Y: {position.y}\n          </p>\n        </div>\n      )}\n    />\n  );\n};\n```\n\n## 4. Higher-Order Components (HOCs)\n\nHOCs are functions that take a component and return a new component with additional functionality.\n\n```jsx\n// HOC for adding loading state\nexport const withLoading = (WrappedComponent) => {\n  return function WithLoadingComponent(props) {\n    if (props.loading) {\n      return <Spinner />;\n    }\n\n    return <WrappedComponent {...props} />;\n  };\n};\n\n// HOC for error boundaries\nexport const withErrorBoundary = (WrappedComponent) => {\n  return class extends Component {\n    state = { hasError: false, error: null };\n\n    static getDerivedStateFromError(error) {\n      return { hasError: true, error };\n    }\n\n    componentDidCatch(error, errorInfo) {\n      console.error(\"Error caught by boundary:\", error, errorInfo);\n    }\n\n    render() {\n      if (this.state.hasError) {\n        return <ErrorFallback error={this.state.error} />;\n      }\n\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n};\n\n// Usage\nconst SafeUserList = withErrorBoundary(withLoading(UserList));\n```\n\n## 5. Component Composition\n\nInstead of inheritance, React favors composition. This pattern allows you to build complex UIs by combining simpler components.\n\n```jsx\n// Base layout components\nexport const Page = ({ children }) => (\n  <div className=\"min-h-screen bg-gray-50\">{children}</div>\n);\n\nexport const PageHeader = ({ children }) => (\n  <header className=\"bg-white shadow-sm border-b\">\n    <div className=\"max-w-7xl mx-auto px-4 py-6\">{children}</div>\n  </header>\n);\n\nexport const PageContent = ({ children }) => (\n  <main className=\"max-w-7xl mx-auto px-4 py-8\">{children}</main>\n);\n\n// Composed page\nconst UserDashboard = () => (\n  <Page>\n    <PageHeader>\n      <h1>User Dashboard</h1>\n      <UserActions />\n    </PageHeader>\n    <PageContent>\n      <UserStats />\n      <RecentActivity />\n    </PageContent>\n  </Page>\n);\n```\n\n## 6. Provider Pattern for Global State\n\nThe Provider pattern is excellent for sharing state across multiple components without prop drilling.\n\n```jsx\n// Theme context\nconst ThemeContext = createContext();\n\nexport const ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  const value = {\n    theme,\n    toggleTheme,\n    colors: theme === 'light' ? lightColors : darkColors\n  };\n\n  return (\n    <ThemeContext.Provider value={value}>\n      <div className={\\`app app--\\${theme}\\`}>\n        {children}\n      </div>\n    </ThemeContext.Provider>\n  );\n};\n\n// Custom hook for consuming theme\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n};\n```\n\n## 7. Container and Presentational Components\n\nSeparate your components into containers (logic) and presentational (UI) components for better maintainability.\n\n```jsx\n// Presentational component\nconst UserListPresentation = ({ users, loading, error, onRefresh }) => {\n  if (loading) return <LoadingSpinner />;\n  if (error) return <ErrorMessage message={error} onRetry={onRefresh} />;\n\n  return (\n    <div className=\"user-list\">\n      {users.map((user) => (\n        <UserCard key={user.id} user={user} />\n      ))}\n    </div>\n  );\n};\n\n// Container component\nconst UserListContainer = () => {\n  const { data: users, loading, error, refetch } = useApi(\"/api/users\");\n\n  return (\n    <UserListPresentation\n      users={users || []}\n      loading={loading}\n      error={error}\n      onRefresh={refetch}\n    />\n  );\n};\n```\n\n## Best Practices\n\n1. **Keep components small and focused** - Each component should have a single responsibility\n2. **Use TypeScript** - Add type safety to catch errors early\n3. **Implement error boundaries** - Gracefully handle component errors\n4. **Optimize re-renders** - Use React.memo, useMemo, and useCallback wisely\n5. **Test your patterns** - Ensure your reusable components work in different scenarios\n\n## Conclusion\n\nThese React patterns provide powerful tools for building scalable applications. The key is to choose the right pattern for your specific use case:\n\n- **Compound components** for flexible component APIs\n- **Custom hooks** for reusable stateful logic\n- **Render props** for dynamic rendering logic\n- **HOCs** for cross-cutting concerns\n- **Composition** for building complex UIs\n- **Provider pattern** for global state management\n\nBy mastering these patterns, you'll be able to write more maintainable, reusable, and scalable React applications that stand the test of time.\n\n---\n\nHave you used these patterns in your React applications? I'd love to hear about your experiences and any other patterns you find useful in the comments below!\n",
    "html": "<h2>author: \"Ehsan Pourhadi\"</h2>\n<h1>Modern React Patterns for Scalable Applications</h1>\n<p>React has evolved significantly since its introduction, and with it, the patterns and practices that help us build better applications. In this article, we'll explore some of the most effective React patterns that can help you create more maintainable, reusable, and scalable code.</p>\n<h2>1. Compound Components</h2>\n<p>Compound components allow you to create flexible APIs by composing multiple components together. This pattern is excellent for building reusable UI components that need to work together.</p>\n<pre><code class=\"language-jsx\">// Before: Monolithic component with many props\n&#x3C;Dropdown\n  trigger=\"Select option\"\n  options={[\n    { value: 'option1', label: 'Option 1' },\n    { value: 'option2', label: 'Option 2' }\n  ]}\n  onSelect={handleSelect}\n  className=\"custom-dropdown\"\n/>\n\n// After: Compound components for flexibility\n&#x3C;Dropdown onSelect={handleSelect}>\n  &#x3C;Dropdown.Trigger>Select option&#x3C;/Dropdown.Trigger>\n  &#x3C;Dropdown.Content>\n    &#x3C;Dropdown.Item value=\"option1\">Option 1&#x3C;/Dropdown.Item>\n    &#x3C;Dropdown.Item value=\"option2\">Option 2&#x3C;/Dropdown.Item>\n  &#x3C;/Dropdown.Content>\n&#x3C;/Dropdown>\n</code></pre>\n<h3>Implementation</h3>\n<pre><code class=\"language-jsx\">const DropdownContext = createContext();\n\nexport const Dropdown = ({ children, onSelect }) => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const value = {\n    isOpen,\n    setIsOpen,\n    onSelect,\n  };\n\n  return (\n    &#x3C;DropdownContext.Provider value={value}>\n      &#x3C;div className=\"dropdown\">{children}&#x3C;/div>\n    &#x3C;/DropdownContext.Provider>\n  );\n};\n\nDropdown.Trigger = ({ children }) => {\n  const { isOpen, setIsOpen } = useContext(DropdownContext);\n\n  return &#x3C;button onClick={() => setIsOpen(!isOpen)}>{children}&#x3C;/button>;\n};\n\nDropdown.Content = ({ children }) => {\n  const { isOpen } = useContext(DropdownContext);\n\n  return isOpen ? &#x3C;div className=\"dropdown-content\">{children}&#x3C;/div> : null;\n};\n</code></pre>\n<h2>2. Custom Hooks for Logic Reuse</h2>\n<p>Custom hooks are perfect for extracting and reusing stateful logic across components. They promote the DRY principle and make your components cleaner.</p>\n<pre><code class=\"language-jsx\">// Custom hook for API data fetching\nexport const useApi = (url, options = {}) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url, options);\n\n        if (!response.ok) {\n          throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n        }\n\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n};\n\n// Usage in components\nconst UserProfile = ({ userId }) => {\n  const { data: user, loading, error } = useApi(\\`/api/users/\\${userId}\\`);\n\n  if (loading) return &#x3C;Spinner />;\n  if (error) return &#x3C;Error message={error} />;\n  if (!user) return &#x3C;NotFound />;\n\n  return &#x3C;ProfileCard user={user} />;\n};\n</code></pre>\n<h2>3. Render Props Pattern</h2>\n<p>The render props pattern provides a way to share code between components using a prop whose value is a function.</p>\n<pre><code class=\"language-jsx\">// Render props component for mouse tracking\nexport const MouseTracker = ({ render }) => {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setPosition({ x: event.clientX, y: event.clientY });\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    return () => window.removeEventListener(\"mousemove\", handleMouseMove);\n  }, []);\n\n  return render(position);\n};\n\n// Usage\nconst App = () => {\n  return (\n    &#x3C;MouseTracker\n      render={(position) => (\n        &#x3C;div>\n          &#x3C;h1>Mouse position:&#x3C;/h1>\n          &#x3C;p>\n            X: {position.x}, Y: {position.y}\n          &#x3C;/p>\n        &#x3C;/div>\n      )}\n    />\n  );\n};\n</code></pre>\n<h2>4. Higher-Order Components (HOCs)</h2>\n<p>HOCs are functions that take a component and return a new component with additional functionality.</p>\n<pre><code class=\"language-jsx\">// HOC for adding loading state\nexport const withLoading = (WrappedComponent) => {\n  return function WithLoadingComponent(props) {\n    if (props.loading) {\n      return &#x3C;Spinner />;\n    }\n\n    return &#x3C;WrappedComponent {...props} />;\n  };\n};\n\n// HOC for error boundaries\nexport const withErrorBoundary = (WrappedComponent) => {\n  return class extends Component {\n    state = { hasError: false, error: null };\n\n    static getDerivedStateFromError(error) {\n      return { hasError: true, error };\n    }\n\n    componentDidCatch(error, errorInfo) {\n      console.error(\"Error caught by boundary:\", error, errorInfo);\n    }\n\n    render() {\n      if (this.state.hasError) {\n        return &#x3C;ErrorFallback error={this.state.error} />;\n      }\n\n      return &#x3C;WrappedComponent {...this.props} />;\n    }\n  };\n};\n\n// Usage\nconst SafeUserList = withErrorBoundary(withLoading(UserList));\n</code></pre>\n<h2>5. Component Composition</h2>\n<p>Instead of inheritance, React favors composition. This pattern allows you to build complex UIs by combining simpler components.</p>\n<pre><code class=\"language-jsx\">// Base layout components\nexport const Page = ({ children }) => (\n  &#x3C;div className=\"min-h-screen bg-gray-50\">{children}&#x3C;/div>\n);\n\nexport const PageHeader = ({ children }) => (\n  &#x3C;header className=\"bg-white shadow-sm border-b\">\n    &#x3C;div className=\"max-w-7xl mx-auto px-4 py-6\">{children}&#x3C;/div>\n  &#x3C;/header>\n);\n\nexport const PageContent = ({ children }) => (\n  &#x3C;main className=\"max-w-7xl mx-auto px-4 py-8\">{children}&#x3C;/main>\n);\n\n// Composed page\nconst UserDashboard = () => (\n  &#x3C;Page>\n    &#x3C;PageHeader>\n      &#x3C;h1>User Dashboard&#x3C;/h1>\n      &#x3C;UserActions />\n    &#x3C;/PageHeader>\n    &#x3C;PageContent>\n      &#x3C;UserStats />\n      &#x3C;RecentActivity />\n    &#x3C;/PageContent>\n  &#x3C;/Page>\n);\n</code></pre>\n<h2>6. Provider Pattern for Global State</h2>\n<p>The Provider pattern is excellent for sharing state across multiple components without prop drilling.</p>\n<pre><code class=\"language-jsx\">// Theme context\nconst ThemeContext = createContext();\n\nexport const ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  const value = {\n    theme,\n    toggleTheme,\n    colors: theme === 'light' ? lightColors : darkColors\n  };\n\n  return (\n    &#x3C;ThemeContext.Provider value={value}>\n      &#x3C;div className={\\`app app--\\${theme}\\`}>\n        {children}\n      &#x3C;/div>\n    &#x3C;/ThemeContext.Provider>\n  );\n};\n\n// Custom hook for consuming theme\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n};\n</code></pre>\n<h2>7. Container and Presentational Components</h2>\n<p>Separate your components into containers (logic) and presentational (UI) components for better maintainability.</p>\n<pre><code class=\"language-jsx\">// Presentational component\nconst UserListPresentation = ({ users, loading, error, onRefresh }) => {\n  if (loading) return &#x3C;LoadingSpinner />;\n  if (error) return &#x3C;ErrorMessage message={error} onRetry={onRefresh} />;\n\n  return (\n    &#x3C;div className=\"user-list\">\n      {users.map((user) => (\n        &#x3C;UserCard key={user.id} user={user} />\n      ))}\n    &#x3C;/div>\n  );\n};\n\n// Container component\nconst UserListContainer = () => {\n  const { data: users, loading, error, refetch } = useApi(\"/api/users\");\n\n  return (\n    &#x3C;UserListPresentation\n      users={users || []}\n      loading={loading}\n      error={error}\n      onRefresh={refetch}\n    />\n  );\n};\n</code></pre>\n<h2>Best Practices</h2>\n<ol>\n<li><strong>Keep components small and focused</strong> - Each component should have a single responsibility</li>\n<li><strong>Use TypeScript</strong> - Add type safety to catch errors early</li>\n<li><strong>Implement error boundaries</strong> - Gracefully handle component errors</li>\n<li><strong>Optimize re-renders</strong> - Use React.memo, useMemo, and useCallback wisely</li>\n<li><strong>Test your patterns</strong> - Ensure your reusable components work in different scenarios</li>\n</ol>\n<h2>Conclusion</h2>\n<p>These React patterns provide powerful tools for building scalable applications. The key is to choose the right pattern for your specific use case:</p>\n<ul>\n<li><strong>Compound components</strong> for flexible component APIs</li>\n<li><strong>Custom hooks</strong> for reusable stateful logic</li>\n<li><strong>Render props</strong> for dynamic rendering logic</li>\n<li><strong>HOCs</strong> for cross-cutting concerns</li>\n<li><strong>Composition</strong> for building complex UIs</li>\n<li><strong>Provider pattern</strong> for global state management</li>\n</ul>\n<p>By mastering these patterns, you'll be able to write more maintainable, reusable, and scalable React applications that stand the test of time.</p>\n<hr>\n<p>Have you used these patterns in your React applications? I'd love to hear about your experiences and any other patterns you find useful in the comments below!</p>"
  },
  "_id": "blog/modern-react-patterns/modern-react-patterns.md",
  "_raw": {
    "sourceFilePath": "blog/modern-react-patterns/modern-react-patterns.md",
    "sourceFileName": "modern-react-patterns.md",
    "sourceFileDir": "blog/modern-react-patterns",
    "contentType": "markdown",
    "flattenedPath": "blog/modern-react-patterns/modern-react-patterns"
  },
  "type": "Blog",
  "slug": "modern-react-patterns",
  "lang": "en"
}